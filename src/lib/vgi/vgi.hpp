/*! \file */
#pragma once

#include <SDL3/SDL.h>
#include <optional>
#include <source_location>
#include <stdexcept>

#include "defs.hpp"
#include "forward.hpp"
#include "memory.hpp"
#include "vulkan.hpp"

namespace vgi {
    /// @brief Initializes the environment context
    /// @param app_name Name of the application, in UTF-8
    void init(const char8_t* app_name);

    /// @brief Starts running the main loop.
    void run();

    /// @brief Requests the main loop runner to stop execution as soon as possible
    void shutdown() noexcept;

    /// @brief Shuts down the environment context
    void quit() noexcept;

    /// @brief An error generated by the library
    struct vgi_error : public std::runtime_error {
        /// @brief THe location of the line that generated the error
        std::source_location location;

        /// @brief Constructs the exception object with an explanatory string
        /// @param what Exception message
        /// @param location Location of the error
        vgi_error(const char* what,
                  std::source_location&& location = std::source_location::current()) :
            std::runtime_error(what), location(std::move(location)) {}

        /// @brief Constructs the exception object with an explanatory string
        /// @param what Exception message
        /// @param location Location of the error
        vgi_error(const std::string& what,
                  std::source_location&& location = std::source_location::current()) :
            std::runtime_error(what), location(std::move(location)) {}

        /// @brief Copy constructor
        /// @param error Error to copy
        vgi_error(const vgi_error& error) : std::runtime_error(error), location(error.location) {}
    };

    /// @brief Exception class to report errors concurred by SDL
    struct sdl_error : public vgi_error {
        /// @brief Constructs rhe exception from the last SDL error that ocurred on the current
        /// thread
        sdl_error(std::source_location&& location = std::source_location::current()) :
            vgi_error(SDL_GetError(), std::move(location)) {}
    };

    /// @brief Represents the time intervals of the current update iteration
    struct timings {
        /// @brief Time point at which the frame started
        std::chrono::steady_clock::time_point time_point;
        /// @brief Time elapsed since the beginning of the first frame
        std::chrono::steady_clock::duration start_time;
        /// @brief Time elapsed since the beginning of the last frame
        std::chrono::steady_clock::duration delta_time;
        /// @brief Seconds elapsed since the beginning of the first frame
        float start;
        /// @brief Seconds elapsed since the beginning of the last frame
        float delta;

    private:
        timings();
        friend void run();
    };

    struct system {
        virtual void on_event(const SDL_Event& event) {}
        virtual void on_update(const timings& ts) {}
        virtual ~system() = default;

        /// @brief At the end of this frame, replace this system with a new one
        /// @param system System that will replace the current one
        void transition_to(std::unique_ptr<system>&& system) noexcept {
            this->transition_target.emplace(std::move(system));
        }

        /// @brief At the end of this frame, replace this system with a new one
        /// @tparam ...Args Argument types
        /// @tparam T system type
        /// @param ...args Arguments to create the new system
        template<std::derived_from<system> T, class... Args>
            requires(std::is_constructible_v<T, Args...>)
        inline void transition_to(Args&&... args) {
            return this->transition_to(std::make_unique<T>(std::forward<Args>(args)...));
        }

        /// @brief At the end of this frame, detach the current system
        void detach() noexcept { this->transition_to(nullptr); }

    private:
        std::optional<std::unique_ptr<system>> transition_target = std::nullopt;
        friend void run();
    };

    /// @brief Adds a new system
    /// @param system system to be added
    size_t add_system(std::unique_ptr<system>&& system);

    /// @brief Access a system
    /// @param key Key of the system to access
    /// @warning If you add a new system, the returned reference may be invalidated.
    system& get_system(size_t key);

    /// @brief Adds a new system to the window
    /// @tparam ...Args Argument types
    /// @tparam T system type
    /// @param ...args Arguments to create the system
    template<std::derived_from<system> T, class... Args>
        requires(std::is_constructible_v<T, Args...>)
    size_t add_system(Args&&... args) {
        return add_system(std::make_unique<T>(std::forward<Args>(args)...));
    }

    /// @brief Adds a new system to the window
    /// @tparam ...Args Argument types
    /// @tparam T system type
    /// @param ...args Arguments to create the system
    template<std::derived_from<system> T, class... Args>
        requires(std::is_constructible_v<T, Args...>)
    T& emplace_system(Args&&... args) {
        const size_t key = add_system<T, Args...>(std::forward<Args>(args)...);
        return static_cast<T&>(get_system(key));
    }

    namespace sdl {
        /// @brief Helper function that parses an SDL result
        /// @param res The result of an SDL function
        /// @param location Location from which the function was called
        /// @throws `sdl_error` if `res == false`
        constexpr VGI_FORCEINLINE void tri(
                bool res, std::source_location&& location = std::source_location::current()) {
            if (!res) [[unlikely]]
                throw sdl_error{std::move(location)};
        }

        /// @brief Helper function that parses an SDL result
        /// @param res The result of an SDL function
        /// @param location Location from which the function was called
        /// @throws `sdl_error` if `res == nullptr`
        template<class T>
        constexpr VGI_FORCEINLINE T* tri(
                T* res, std::source_location&& location = std::source_location::current()) {
            if (!res) [[unlikely]]
                throw sdl_error{std::move(location)};
            return res;
        }
    }  // namespace sdl

    namespace vkn {
        /// @brief Allocate command buffers from an existing command pool
        /// @param device Logical device that owns the command pool
        /// @param alloc_info Pointer to a structure describing parameters of the allocation
        /// @param cmdbufs Pointer to an array of `vk::CommandBuffer` handles in which the resulting
        /// command buffer objects are returned
        VGI_FORCEINLINE void allocateCommandBuffers(vk::Device device,
                                                    const vk::CommandBufferAllocateInfo& alloc_info,
                                                    vk::CommandBuffer* cmdbufs) {
            vk::detail::resultCheck(device.allocateCommandBuffers(&alloc_info, cmdbufs),
                                    VULKAN_HPP_NAMESPACE_STRING "::Device::allocateCommandBuffers");
        }

        /// @brief Allocate descriptor sets from an existing descriptor pool
        /// @param device Logical device that owns the descriptor pool
        /// @param alloc_info Pointer to a structure describing parameters of the allocation
        /// @param cmdbufs Pointer to an array of `vk::DescriptorSet` handles in which the resulting
        /// descriptor set objects are returned
        VGI_FORCEINLINE void allocateDescriptorSets(vk::Device device,
                                                    const vk::DescriptorSetAllocateInfo& alloc_info,
                                                    vk::DescriptorSet* cmdbufs) {
            vk::detail::resultCheck(device.allocateDescriptorSets(&alloc_info, cmdbufs),
                                    VULKAN_HPP_NAMESPACE_STRING "::Device::allocateDescriptorSets");
        }
    }  // namespace vkn
}  // namespace vgi
