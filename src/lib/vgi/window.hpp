/*! \file */
#pragma once

#include <SDL3/SDL.h>
#include <cstdint>
#include <deque>
#include <memory>
#include <optional>
#include <tuple>
#include <type_traits>
#include <utility>

#include "collections/slab.hpp"
#include "device.hpp"
#include "forward.hpp"
#include "resource.hpp"
#include "vgi.hpp"
#include "vulkan.hpp"

namespace vgi {
    /// @brief A layer that attaches to the update loop of a window
    /// @details Layers may be thought of as the systems of a window.
    struct layer {
        /// @brief Notifies the layer is being attached to a window
        /// @param w The window to which the layer is being attached
        virtual void on_attach(window& w) {}

        /// @brief Notifies an event was received.
        /// @details Only events generated by this window, or those that are not associated to a
        /// specific window, are visible.
        virtual void on_event(window& w, const SDL_Event& event) {}

        /// @brief Called every time a new frame is being processed
        /// @param cmdbuf Command buffer of the frame. You can perform non-rendering operations
        /// before moving on to the render stage.
        /// @param current_frame Index of the current frame. Useful for cyclic structures, such as
        /// `vgi::uniform_buffer` or `vgi::descriptor_pool`.
        /// @param ts Frame timings
        virtual void on_update(window& w, vk::CommandBuffer cmdbuf, uint32_t current_frame,
                               const timings& ts) {}

        /// @brief Called every time a frame must be rendered
        /// @param cmdbuf Command buffer where the rendering commands must be recorded
        /// @param current_frame Index of the current frame. Useful for cyclic structures, such as
        /// `vgi::uniform_buffer` or `vgi::descriptor_pool`.
        virtual void on_render(window& w, vk::CommandBuffer cmdbuf, uint32_t current_frame) {}

        /// @brief Notifies the layer is being detached from a window
        /// @param w The window from which the layer is being detached
        virtual void on_detach(window& w) {}

        virtual ~layer() = default;

        /// @brief At the end of this frame, replace this layer with a new one
        /// @param layer layer that will replace the current one
        void transition_to(std::unique_ptr<layer>&& layer) noexcept {
            this->transition_target.emplace(std::move(layer));
        }

        /// @brief At the end of this frame, replace this layer with a new one
        /// @tparam ...Args Argument types
        /// @tparam T layer type
        /// @param ...args Arguments to create the new layer
        template<std::derived_from<layer> T, class... Args>
            requires(std::is_constructible_v<T, Args...>)
        inline void transition_to(Args&&... args) {
            return this->transition_to(std::make_unique<T>(std::forward<Args>(args)...));
        }

        /// @brief At the end of this frame, detach the current layer
        void detach() noexcept { this->transition_to(nullptr); }

    private:
        std::optional<std::unique_ptr<layer>> transition_target;
        friend struct window;
    };

    /// @brief Handle to a presentable window
    struct window : public system {
        /// @brief Maximum number of frames that can waiting to be presented at the same time.
        constexpr static inline const uint32_t MAX_FRAMES_IN_FLIGHT = VGI_MAX_FRAMES_IN_FLIGHT;

        /// @brief Create a window with the specified properties
        /// @param device Device to be used for hardware acceleration
        /// @param title The title of the window, in UTF-8 encoding
        /// @param width The width of the window
        /// @param height The height of the window
        /// @param flags The flags that determine the properties and behaviour of the window
        /// @param vsync Specifies whether we want to limit the frame rate to follow the rate at
        /// which the monitor can present frames
        /// @param hdr10 Enables/Disables high-definition 10-bit display format
        window(const device& device, const char8_t* title, int width, int height,
               SDL_WindowFlags flags = 0, bool vsync = true, bool hdr10 = false);

        window(const window&) = delete;
        window& operator=(const window&) = delete;

        /// @brief Move constructor for `window`
        /// @param other Object to move
        window(window&& other) noexcept :
            handle(std::exchange(other.handle, nullptr)), surface(std::move(other.surface)),
            physical(other.physical), logical(std::move(other.logical)),
            allocator(std::move(other.allocator)), queue(std::move(other.queue)),
            cmdpool(std::move(other.cmdpool)), swapchain(std::move(other.swapchain)),
            has_mailbox(other.has_mailbox), has_hdr10(other.has_hdr10) {}

        /// @brief Move assignment for `window`
        /// @param other Object to move
        window& operator=(window&& other) noexcept {
            if (this == &other) [[unlikely]]
                return *this;
            std::destroy_at(this);
            std::construct_at(this, std::move(other));
            return *this;
        }

        /// @brief Color format used by the window to present images
        inline vk::Format format() const noexcept { return this->swapchain_info.imageFormat; }
        /// @brief Size of the rendering surface, in pixels
        inline vk::Extent2D draw_size() const noexcept { return this->swapchain_info.imageExtent; }

        /// @brief Checks whether the windows has the provided identifier
        /// @details This is necessary to map window events to a specific `window` object.
        /// @param id a window identifier
        /// @return `true` if the window is identified by `id`, `false` otherwise
        inline bool operator==(SDL_WindowID id) const noexcept {
            return SDL_GetWindowID(this->handle) == id;
        }

        /// @brief Get access to the methods of `vk::Device`
        constexpr const vk::Device* operator->() const noexcept { return &this->logical; }
        /// @brief Get access to the methods of `vk::Device`
        constexpr vk::Device* operator->() noexcept { return &this->logical; }
        /// @brief Casts `window` to it's underlying `SDL_Window*`
        constexpr operator SDL_Window*() const noexcept { return this->handle; }
        /// @brief Casts `window` to it's underlying `vk::SurfaceKHR`
        constexpr operator vk::SurfaceKHR() const noexcept { return this->surface; }
        /// @brief Casts `window` to it's underlying `VkSurfaceKHR`
        inline operator VkSurfaceKHR() const noexcept { return this->surface; }
        /// @brief Casts `window` to it's underlying `vk::Device`
        constexpr operator vk::Device() const noexcept { return this->logical; }
        /// @brief Casts `window` to it's underlying `VkDevice`
        inline operator VkDevice() const noexcept { return this->logical; }
        /// @brief Casts `window` to it's underlying `VmaAllocator`
        constexpr operator VmaAllocator() const noexcept { return this->allocator; }

        /// @brief Adds a new layer to the window
        /// @param layer layer to be added
        size_t add_layer(std::unique_ptr<layer>&& layer) {
            layer->on_attach(*this);
            return this->layers.emplace(std::move(layer));
        }

        /// @brief Adds a new layer to the window
        /// @tparam ...Args Argument types
        /// @tparam T layer type
        /// @param ...args Arguments to create the layer
        template<std::derived_from<layer> T, class... Args>
            requires(std::is_constructible_v<T, Args...>)
        size_t add_layer(Args&&... args) {
            return this->add_layer(std::make_unique<T>(std::forward<Args>(args)...));
        }

        void on_event(const SDL_Event& event) override;
        void on_update(const timings& ts) override;

        /// @brief Creates a new buffer
        /// @param create_info Creation information for the `vk::Buffer`
        /// @param alloc_create_info Creation information fo the `VmaAllocation`
        /// @param alloc_info Information about allocated memory. It can be later fetched using
        /// function `vmaGetAllocationInfo`.
        /// @return The created `vk::Buffer` and it's associated `VmaAllocation`
        std::pair<vk::Buffer, VmaAllocation VGI_RESTRICT> create_buffer(
                const vk::BufferCreateInfo& create_info,
                const VmaAllocationCreateInfo& alloc_create_info,
                VmaAllocationInfo* alloc_info = nullptr) const;

        /// @brief Closes the window, releasing all it's resources
        VGI_FORCEINLINE void close() && { window tmp = std::move(*this); }

        ~window() noexcept;

    private:
        struct flying_command_buffer {
            vk::CommandBuffer cmdbuf;
            vk::Fence fence;
        };

        struct depth_texture {
            vk::Image image;
            vk::ImageView view;
            VmaAllocation allocation;

            depth_texture(vk::Device logical, VmaAllocator allocator, vk::Format format,
                          uint32_t width, uint32_t height);
            void destroy(vk::Device logical, VmaAllocator allocator) && noexcept;
        };

        SDL_Window* VGI_RESTRICT handle;
        vk::SurfaceKHR surface;
        const device& physical;
        vk::Device logical;
        VmaAllocator VGI_RESTRICT allocator;
        vk::Queue queue;
        vk::CommandPool cmdpool;
        vk::SwapchainKHR swapchain;
        vk::SwapchainCreateInfoKHR swapchain_info;
        unique_span<vk::Image> swapchain_images;
        unique_span<vk::ImageView> swapchain_views;
        unique_span<depth_texture> swapchain_depths;
        vk::Format depth_format;
        std::deque<flying_command_buffer> flying_cmdbufs;
        vk::CommandBuffer cmdbufs[MAX_FRAMES_IN_FLIGHT];
        vk::Fence in_flight[MAX_FRAMES_IN_FLIGHT];
        vk::Semaphore present_complete[MAX_FRAMES_IN_FLIGHT];
        unique_span<vk::Semaphore> render_complete;
        uint32_t current_frame = 0;
        collections::slab<std::unique_ptr<layer>> layers;
        bool has_mailbox;
        bool has_hdr10;

        void create_swapchain(uint32_t width, uint32_t height, bool vsync, bool hdr10);
        void create_swapchain(bool vsync, bool hdr10);

        friend struct command_buffer;
        friend struct frame;
    };
}  // namespace vgi

/// @brief Checks whether the windows has the provided identifier
/// @details This is necessary to map window events to a specific `window` object.
/// @param id a window identifier
/// @param rhs a window
/// @return `true` if the window is identified by `id`, `false` otherwise
inline bool operator==(SDL_WindowID id, const vgi::window& rhs) noexcept {
    return SDL_GetWindowID(rhs) == id;
}
